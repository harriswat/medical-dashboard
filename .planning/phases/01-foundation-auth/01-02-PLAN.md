---
phase: 01-foundation-auth
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/app/(auth)/login/page.tsx
  - src/app/(auth)/auth/callback/route.ts
  - src/app/(dashboard)/layout.tsx
  - src/app/(dashboard)/today/page.tsx
  - src/app/(dashboard)/history/page.tsx
  - supabase/migrations/001_initial_schema.sql
  - supabase/migrations/002_sync_log.sql
autonomous: true
must_haves:
  truths:
    - "Harris can enter harriswatk@gmail.com and receive a magic link email"
    - "Kent can enter kentwatkins1@me.com and receive a magic link email"
    - "After clicking magic link, user is redirected to /today and session is active"
    - "Session persists across browser close and reopen (no re-login needed)"
    - "Unauthenticated users are redirected from /today and /history to /login"
    - "Supabase profiles table exists with RLS policies enabled"
    - "Sync log table exists for attribution tracking (not a write queue -- app is read-only when offline per user decision)"
  artifacts:
    - path: "src/app/(auth)/login/page.tsx"
      provides: "Magic link login form"
      contains: "signInWithOtp"
    - path: "src/app/(auth)/auth/callback/route.ts"
      provides: "Auth callback for magic link redirect"
      contains: "exchangeCodeForSession"
    - path: "src/app/(dashboard)/layout.tsx"
      provides: "Authenticated dashboard layout shell"
      contains: "redirect"
    - path: "supabase/migrations/001_initial_schema.sql"
      provides: "Profiles table with RLS"
      contains: "CREATE TABLE"
    - path: "supabase/migrations/002_sync_log.sql"
      provides: "Sync log for attribution tracking"
      contains: "sync_log"
  key_links:
    - from: "src/app/(auth)/login/page.tsx"
      to: "Supabase Auth API"
      via: "signInWithOtp call"
      pattern: "signInWithOtp"
    - from: "src/app/(auth)/auth/callback/route.ts"
      to: "src/lib/supabase/server.ts"
      via: "exchangeCodeForSession"
      pattern: "exchangeCodeForSession"
    - from: "src/app/(dashboard)/layout.tsx"
      to: "/login"
      via: "redirect when unauthenticated"
      pattern: "redirect.*login"
---

<objective>
Implement the complete magic link auth flow (login page, callback route, protected dashboard layout), create placeholder dashboard pages, and define the Supabase database schema (profiles + sync_log tables with RLS). This makes the app usable -- Harris and Kent can log in and stay logged in forever.

Purpose: Auth is the gate to every feature. Persistent magic link sessions mean neither user has to deal with passwords or re-login during a stressful recovery period. The schema establishes the data foundation for Phases 2-4.

Output: Working magic link auth for Harris and Kent, protected dashboard routes, and Supabase schema ready for real-time data.
</objective>

<execution_context>
@/Users/harriswatkins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/harriswatkins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-auth/01-RESEARCH.md
@.planning/phases/01-foundation-auth/01-CONTEXT.md
@.planning/phases/01-foundation-auth/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Magic link login page and auth callback</name>
  <files>
    src/app/(auth)/login/page.tsx
    src/app/(auth)/auth/callback/route.ts
  </files>
  <action>
    1. Create login page at `src/app/(auth)/login/page.tsx`:
       - Client component ('use client')
       - Simple form: email input + "Send Magic Link" button using shadcn Button and Input
       - On submit: call `supabase.auth.signInWithOtp({ email, options: { emailRedirectTo: window.location.origin + '/auth/callback' } })`
       - Show "Check your email for the magic link!" after successful send
       - Show error message if email send fails
       - Validate email client-side: only allow harriswatk@gmail.com and kentwatkins1@me.com (show friendly message for other emails: "This app is for Harris and Kent only")
       - Style: centered card layout, warm and inviting, use soft greens. Think Headspace login -- minimal, calming.

    2. Create auth callback route at `src/app/(auth)/auth/callback/route.ts`:
       - GET handler that extracts `code` from URL search params
       - Exchange code for session using `supabase.auth.exchangeCodeForSession(code)`
       - On success: redirect to `/today`
       - On error: redirect to `/login?error=auth`
  </action>
  <verify>
    1. `npx tsc --noEmit` passes
    2. Navigate to localhost:3000 -- should redirect to /login
    3. Enter harriswatk@gmail.com -- should show "Check your email" message
    4. Enter a random email -- should show "This app is for Harris and Kent only"
  </verify>
  <done>
    Login page renders with magic link form. Only Harris and Kent emails are accepted. Auth callback route exchanges code for session and redirects to /today.
  </done>
</task>

<task type="auto">
  <name>Task 2: Protected dashboard layout, placeholder pages, and database schema</name>
  <files>
    src/app/(dashboard)/layout.tsx
    src/app/(dashboard)/today/page.tsx
    src/app/(dashboard)/history/page.tsx
    supabase/migrations/001_initial_schema.sql
    supabase/migrations/002_sync_log.sql
  </files>
  <action>
    1. Create dashboard layout at `src/app/(dashboard)/layout.tsx`:
       - Server component
       - Check auth: `const supabase = await createClient(); const { data: { user } } = await supabase.auth.getUser()`
       - If no user, `redirect('/login')`
       - Render children (the actual page content) -- no nav yet, that comes in Plan 03
       - Pass user info to children if needed via React context or props

    2. Create placeholder Today page at `src/app/(dashboard)/today/page.tsx`:
       - Server component
       - Get user from Supabase server client
       - Show: "Welcome, [user email]" and "Today's schedule will appear here"
       - This is a placeholder -- Plan 03 adds the real shell

    3. Create placeholder History page at `src/app/(dashboard)/history/page.tsx`:
       - Server component
       - Show: "History will appear here"

    4. Create Supabase schema migration at `supabase/migrations/001_initial_schema.sql`:

       ```sql
       -- Create profiles table (extends auth.users)
       CREATE TABLE IF NOT EXISTS public.profiles (
         id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
         email TEXT NOT NULL,
         display_name TEXT NOT NULL,
         role TEXT NOT NULL CHECK (role IN ('patient', 'caregiver')),
         created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
         updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
       );

       -- Enable RLS
       ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

       -- Both Harris and Kent can see all profiles (they're a care team)
       CREATE POLICY "Care team can view all profiles"
         ON public.profiles FOR SELECT
         USING (auth.uid() IS NOT NULL);

       -- Users can update their own profile
       CREATE POLICY "Users can update own profile"
         ON public.profiles FOR UPDATE
         USING (auth.uid() = id)
         WITH CHECK (auth.uid() = id);

       -- Users can insert their own profile (on first login)
       CREATE POLICY "Users can insert own profile"
         ON public.profiles FOR INSERT
         WITH CHECK (auth.uid() = id);

       -- Index for RLS performance
       CREATE INDEX IF NOT EXISTS idx_profiles_id ON public.profiles(id);

       -- Auto-create profile on signup via trigger
       CREATE OR REPLACE FUNCTION public.handle_new_user()
       RETURNS TRIGGER AS $$
       BEGIN
         INSERT INTO public.profiles (id, email, display_name, role)
         VALUES (
           NEW.id,
           NEW.email,
           CASE
             WHEN NEW.email = 'harriswatk@gmail.com' THEN 'Harris'
             WHEN NEW.email = 'kentwatkins1@me.com' THEN 'Kent'
             ELSE split_part(NEW.email, '@', 1)
           END,
           CASE
             WHEN NEW.email = 'harriswatk@gmail.com' THEN 'patient'
             WHEN NEW.email = 'kentwatkins1@me.com' THEN 'caregiver'
             ELSE 'patient'
           END
         );
         RETURN NEW;
       END;
       $$ LANGUAGE plpgsql SECURITY DEFINER;

       -- Trigger to auto-create profile
       DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
       CREATE TRIGGER on_auth_user_created
         AFTER INSERT ON auth.users
         FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

       -- Updated_at auto-update trigger
       CREATE OR REPLACE FUNCTION public.handle_updated_at()
       RETURNS TRIGGER AS $$
       BEGIN
         NEW.updated_at = NOW();
         RETURN NEW;
       END;
       $$ LANGUAGE plpgsql;

       CREATE TRIGGER profiles_updated_at
         BEFORE UPDATE ON public.profiles
         FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

       -- Enable Realtime for profiles table
       ALTER PUBLICATION supabase_realtime ADD TABLE public.profiles;
       ```

    5. Create sync log migration at `supabase/migrations/002_sync_log.sql`:
       NOTE: The sync_log table is for **attribution tracking only** (recording who made what change and when). It is NOT a write queue or offline mutation queue. Per user decision, the app is **read-only when offline** -- no queued mutations, no conflict resolution needed. Supabase handles concurrent writes natively via timestamp ordering (satisfies REQ-SYNC-04).

       ```sql
       -- Sync log for attribution tracking: records who changed what and when.
       -- This is NOT an offline write queue. The app is read-only when offline (per user decision).
       -- Conflict resolution (REQ-SYNC-04): Supabase handles this natively via last-write-wins
       -- timestamp ordering on the server. No client-side conflict resolution is needed.
       CREATE TABLE IF NOT EXISTS public.sync_log (
         id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
         table_name TEXT NOT NULL,
         record_id UUID NOT NULL,
         action TEXT NOT NULL CHECK (action IN ('INSERT', 'UPDATE', 'DELETE')),
         changed_by UUID REFERENCES auth.users(id),
         changed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
         payload JSONB
       );

       ALTER TABLE public.sync_log ENABLE ROW LEVEL SECURITY;

       -- Both users can see all sync logs (shared care team)
       CREATE POLICY "Care team can view sync logs"
         ON public.sync_log FOR SELECT
         USING (auth.uid() IS NOT NULL);

       -- Authenticated users can insert sync logs
       CREATE POLICY "Authenticated users can insert sync logs"
         ON public.sync_log FOR INSERT
         WITH CHECK (auth.uid() IS NOT NULL);

       CREATE INDEX idx_sync_log_table ON public.sync_log(table_name);
       CREATE INDEX idx_sync_log_changed_at ON public.sync_log(changed_at);

       -- Enable Realtime
       ALTER PUBLICATION supabase_realtime ADD TABLE public.sync_log;
       ```

       Print clear instructions for the user to run these migrations in the Supabase SQL Editor.
  </action>
  <verify>
    1. `npx tsc --noEmit` passes with no errors
    2. Navigate to localhost:3000/today directly -- should redirect to /login (unauthenticated)
    3. Verify migration SQL files exist at supabase/migrations/
    4. Review 002_sync_log.sql confirms attribution-only purpose in comments
  </verify>
  <done>
    Dashboard layout protects routes (redirects unauthenticated users). Placeholder Today and History pages render. Schema migrations define profiles table with RLS and sync_log table for attribution tracking. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npm run dev` starts without errors
2. `npx tsc --noEmit` passes
3. Unauthenticated visit to / redirects to /login
4. Login page accepts only harriswatk@gmail.com and kentwatkins1@me.com
5. After magic link authentication, user lands on /today with their email displayed
6. Closing browser and reopening maintains the session (no re-login)
7. Migration SQL files exist and are ready for Supabase SQL Editor
</verification>

<success_criteria>
- Magic link login works for Harris and Kent only
- Auth callback exchanges code for session and redirects to /today
- Dashboard routes are protected (redirect to /login when unauthenticated)
- Session persists across browser restarts
- Database schema (profiles + sync_log) is defined with RLS policies
- Sync log is clearly documented as attribution-only (not a write queue)
- TypeScript compiles with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-auth/01-02-SUMMARY.md`
</output>
